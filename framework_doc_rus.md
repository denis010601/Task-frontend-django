# Описание

Данный фреймворк разработан для быстрого и масштабируемого создания интерактивных заданий в проекте онлайн образования "Дети и наука".
 
    childrenscience.ru
 
Он представляет из себя набор виджетов с различными опциями, из которых конфигурируется конкретное задание.



# О версиях фреймворка

В проекте "Дети и наука" достаточно много интерактивных заданий сделаны с использованием более старых версий этого фреймворка. В разных заданиях в проекте используются версии, имеющие индексы:
    
    0.0.0
    
    0.0.1
    
    1.0.0
    
    1.0.1
    
    2.0.0
    
    2.0.1

Данную версию мы обозначили индексом:
 
    3.0.0
 
Эта версия разработана на основе версии 2.0.1 и не имеет обратной совместимости с предыдущими версиями.

Вероятно, все предыдущие версии так же не совместимы между собой.



# Установка

В репозиторий включены файлы самого фреймворка, а также файлы интерактивных заданий (структуру см. ниже).

Для сборки из исходников используется Gruntjs (и плагины).

Для его установки нужно запустить npm install из папки _framework.

    npm install
    
После чего с помощью команды npx grunt (в папке _framework) можно будет собрать используемые файлы 
или запустить отслеживание изменений и автоматическое обновление сборки для дальнейшей разработки (конфиг gruntjs настраивается в файле gruntfile.js).

    npx grunt

Во фреймворке используется jQuery (и плагины). Нужные файлы и их минимизированные версии (libs.min.css и libs.min.js) уже включены в репозиторий.

То есть эти два компонента не нужно собирать из исходников (хотя они тоже есть), а нужно подключать в задания уже готовые версии.

Всего для использования фреймворка в задании должно быть подключено 4 файла:

    _framework/libs.min.css
    _framework/style.css
    
    _framework/libs.min.js
    _framework/index.js

Для быстрого начала использования фреймворка в разработке задач в репозиторий включена папка с готовой к работе версией, не требующая описанных процедур (версия может незначительно отставать от актуальной):

    _framework_ready



# Файловая структура

Файловая структура выглядит следующим образом:

    (all courses tasks folder)
    +-- framework folder
        +-- source files
        +-- images and fonts
        +-- gruntjs config
        +-- compiled files
    +-- demo folder
    +-- course folder
        +-- lesson folder
            +-- task folder

В таком же виде фреймворк используется в проекте.

Для удобства для каждого курса создана своя папка с интерактивными заданиями, а в ней задания по папкам разделены на уроки.
Чаще всего мы имеем только одно задание на урок, но такая структура делает поддержку более удобной.

Этим обусловлены пути к используемым файлам фреймворка, указанные во всех заданиях:

    ../../../_framework/index.js
    
И т.д.

Папка demo используется для хранения заданий, созданных специально для разработки фреймворка, либо заданий, созданных для демонстрации функционала.



# Общие принципы

Каждое задание является web-страничкой со своей HTML и CSS структурой.

Содержание интерактивного задания описывается в одной переменной task в стиле, похожем на JSON, заданной в файле index.html задания.

По сути это массив из объектов, первый из которых "зарезервирован" для каких либо общих настроек задания, а каждый последующий является описанием одного шага задания.

    var task = [
        
        // settings
        {},

        // step 1
        {},
        
        // step 2
        {}
        
    ];
 
Предполагается, что на каждом шаге пользователь дает ответы на задачу через различные интерактивные виджеты (например, заполняя текстовые поля), после чего происходит проверка правильности ответов и переход на следующий шаг в случае, если все ответы даны верно.
 
Проверка обычно запускается нажатием на соответствующую кнопку, но может быть запущена и автоматически.
 
Также шаг может быть использован для представления информации (например, условия задачи или вывода по итогам решения), и не иметь никаких проверяемых ответов. В этом случае кнопка проверки инициирует переход на следующий шаг, если он есть.

Проверка последнего шага задания вызывает overlay с сообщением об успешном решении.

Если проверка не была успешной, пользователю может быть показана подсказка, если она описана в настройках шага задания.

В стандартном варианте шаги изолированы друг от друга, то есть задание может быть вызвано с любого шага, и это не повлияет на логику его прогресса. Это может измениться, если в рамках задания будет описан дополнительный или переопределен существующий функционал фреймворка (см. ниже).

Пользователь может начать проходить заново любой шаг или задание целиком (reload).



# Конфигурация шага задания и виджеты

Объект с шагом задания содержит в себе "свойства - опции шага" и "свойства - виджеты".
    
    // step 1
    
    {
        "nextStepDelay": 800,
        "button": true,
        "buttonText": "Проверить",
    
        "test_images":
            [
                {
                    "classes": "task_description",
                    "value": "2<sup class='small-font-sup'>2020</sup> = ?"
                },
                
                {
                    "classes": "step-description",
                    "value": "Что объединяет значения степеней двойки в каждом классе?"
                },
            ],
            
        "test_textfields": 
            [
                {
                    "removeCharacters": ["(", ")", " "],
                    "replaceCommas": true,
                    "checkAnyOrder": true
                },
                
                {
                    "value": "1.5000", 
                    "classes": "__textfield1"
                },
                {
                    "value": "0.0858", 
                    "classes": "__textfield2"
                }
            ]
    }
  
Условно, любые отображаемые элементы задачи являются одним из виджетов.
Часть виджетов используется только для отображения чего либо:

    test_images.js
    widget_list.js

Часть является интерактивными элементами, не влияющими на результаты проверки:

    test_custom_js_button.js
    
    test_explain.js
    test_help.js
    
    widget_button.js
    widget_overlay.js
    
    test_preloadimg.js 

Основная часть виджетов предполагает какой-либо способ ввода правильного ответа:
    
    test_textfields.js
    
    test_clickable.js
    test_multiclickable.js
    
    test_sortable.js
    test_drag_n_drop.js
    
    test_checkbox.js
    test_radiobutton.js

Это полный список входящих в данную версию виджетов.

В описании виджетов заложено их содержание (картинки, текст, html) и логика проверок (указаны верные ответы), а также некоторые другие параметры.



# Визуальное оформление, CSS

Для всех элементов, создаваемых виджетами, прописаны достаточные стили по умолчанию. 

Однако, оформление задания требует как минимум задать расположение всех элементов, для чего используется отдельный css-файл задания. Также вы можете переопределить в нем уже существующие стили элементов.

В качестве селекторов может быть использован уникальный id элемента, общий класс однотипных элементов (например, для изменения стилей всех текстовых полей в задании) или заданный в настройках виджета индивидуальный класс для элемента/группы элементов (см. ниже).

Элементы уникальны (имеют уникальные id) только в рамках одного шага задания, поэтому для индивидуальных стилей используются селекторы по атрибуту data-task (который содержит номер текущего шага) родителського блока #field.

Таким образом, селекторы в css-файле задания могут выглядеть следующим образом:

    // общие стили для текстовых полей 
    .textfield {}
    
    // общие стили для текстовых полей во втором шаге
    #field[data-task="2"] .textfield {} 

    // стили для первого элемента виджета test_textfields в первом шаге задания
    #field[data-task="1"] #textfield1 {}
    
    // стили для элемента, которому в настройках виджета в первом шаге 
    // был присвоен индивидуальный класс textfield_wide
    #field[data-task="1"] .textfield_wide {}
    
Активная область задания ограничена блоком #field и имеет размеры 960 x 490 px. Все элементы обычно позиционируются абсолютно относительно левого верхнего угла этого блока.

В некоторых механизмах фреймворка используется временное присвоение дополнительных классов блоку #field (например, при успешной проверке шага задания блок #field получает класс .finished), что так же используется в оформлении.  

В интерфейсе урока задания выводятся через iframe, который обеспечивает изменение размера области задания под размер окна.
    
    
    
# Собственные параметры шага задания

В каждом шаге задания могут быть (помимо виджетов) описаны несколько дополнительных свойств этого шага. Здесь приведены все существующие на данный момент параметры:

    // step 1
    
    {
        "nextStepDelay": 300,
        
        "button": true,
        "buttonActive": true,
        "buttonText": "text on button",
        
        "onload_custom_js": "functionName",
        "finish_custom_js": "functionName"
    
        ...
    }
    
Свойство nextStepDelay устанавливает задержку (в мс) до того, как будет совершен переход на следующий шаг (вызвана функция nextStep). Эту задержку следует устанавливать для показа какого либо контента по итогам шага, либо для того, чтобы дать время на исполнение функции finish_custom_js (это свойство будет описано ниже).

Если свойство nextStepDelay не задано или задано нулевое значение - переход на следующий шаг не произойдет, и функцию nextStep нужно будет вызвать каким-то другим способом (внутри finish_custom_js или с помощью test_custom_js_button).

Свойства, связанные с кнопкой проверки, задают ее наличие ("button": true), ее активацию (по умолчанию кнопка "Проверить" активируется виджетом при заполнении всех или части ответов, но может быть активирована с сакмого начала) и текст, который она содержит.

Опции вызова дополнительных функций позволяют наиболее сильно кастомизировать задание. В качестве значения эта опция должна получить имя функции, которая обычно прописана в теле index.html задания.

Свойство onload_custom_js отвечает за вызов функции сразу после того, как сгенерированные DOM-элементы шага задания будут добавлены в тело документа, но до того, как они будут показаны (отменится класс .disappeared, в котором установлено свойство opacity: 0;)

Функция, заданная в finish_custom_js, будет вызвана по итогу успешной проверки, сразу после вызовов методов .onFinish всех соответствующих элементов. Если требуется, следует указать достаточное время задержки до перехода на следующий шаг, чтобы функция успела выполнить все нужные действия.

Так же ползовательская функция может быть вызвана с помощью виджета test_custom_js_button, который будет описан ниже.

Значения по умолчанию:

    "nextStepDelay": unset (интерпретируется как false),
    
    "button": unset (интерпретируется как false),
    "buttonActive": unset (интерпретируется как false),
    "buttonText": "Проверить",
    
    "onload_custom_js": unset,
    "finish_custom_js": unset



# Стандартные элементы шага

В каждом шаге задания существуют элементы, генерируемые независимо от содержания. Это индикатор шага задания (в верхней части) и кнопка перезагрузки шага или всего задания целиком (#reloadButton).

Также в каждом шаге существует блок .button-block, предназанченный для позиционирования кнопок, однако, он может быть пустым.

На данный момент не реализовано опций, чтобы как-либо воздействовать на эти элементы (но вы можете использовать css).



# Переопределение функций

Для создания нестандартных заданий любые методы фреймворка и виджетов могут быть переопределены в файле index.html задания.



# Виджеты

Виджеты определены во фреймворке как объекты, имеющие методы создания DOM-элементов, взаимодействия с ними, проверки результатов, поведения по окончанию шага задания и некоторые другие.

Из описания шага задания виджеты получают параметры для созджания своих элементов и некоторые дополнительные опции.

Некоторые виджеты используются только как служебные в рамках других функций фреймворка и не предполагают прямого описания в свойствах шага задания (widget_button, widget_overlay).

Каждый виджет может быть использован в шаге задачи только один раз!

    Работа по рефакторингу виджетов (как и всего фреймворка) 
    далека от завершения, поэтому прямо в документации 
    можно встретить описания неудачных решений, не выясненной до конца 
    логики алгоритма или некоторые запланированные задачи по разработке.



# Элемент .inner-element и css

В большинстве случаев виджетами создаются элементы, имеющие следующую структуру:

    <div>
        <div class="inner-element">
            ...content
        </div>
    </div> 

Наличие дополнительного внутреннего контейнера является устаревшей особенностью фреймворка.

Изначально это было сделано для вертикального выравнивания содержимого через свойство display: table; однако, это больше не актуально.

Внутренние стили фреймворка настроены так, чтобы все стилевые параметры можно было задавать внешнему контейнеру, игнорируя наличие внутреннего блока .inner-element (исключением могут быть некоторые динамические стили, связанные с интерактивностью виджета).

Все селекторы также присваиваются внешнему контейнеру.



# test_images

Этот виджет (по сути - только этот) используется для представления любой информации. Он создает блоки с указанным содержимым. Первый элемент массива здесь не является контейнером для параметров (то есть общих параметров нет).

    "test_images":
        [
            {
                "classes": "task_description",
                "value": "Текст описания задания"
            },

            {
                "classes": "__image1",
                "value": "<img src='image1.png' ... >"
            },

            {
                "classes": "__list1",
                "value": "<ul class='list-example'><li>Item 1</li><li>Item 2</li></ul>"
            }
        ]
        
Для каждого элемента можно задать следующие параметры:

    classes (не обязателен) - добавляет элементу установленные классы
    
    value - описывает содержимое элемента, это может быть текст или любой html

Структура созданных элементов будет выглядеть так:

    <div class="image task_description" id="image0">
        <div class="inner-element">
            Текст описания задания
        </div>
    </div>
    
    <div class="image __image1" id="image1">
        <div class="inner-element">
            <img src='image1.png' ... >
        </div>
    </div>
    
    <div class="image __list1" id="image2">
        <div class="inner-element">
            <ul class='list-example'>
                <li>
                    Item 1
                </li>
                <li>
                    Item 2
                </li>
            </ul>
        </div>
    </div>
            
Во фреймворке существуют преднастроенные классы для описания задания и шага задания, которые достаточно присвоить элементу, чтобы получить нужное оформление и позиционирование:

    task_description

    step-description



# widget_list

Это вспомогательный виджет, с помощью которого отрисовываются нумерованные списки со стрелочками в стиле общего дизайна заданий. С точки зрения html это реализовано не как список, а как набор блоков div и псевдоэлементов.

Объявление:

    "widget_list":
        [
            {
                "list_length": 3,
                "classes": "__list1"
            }
        ],
        
Возможные параметры:

    classes (не обязателен) - добавляет родительскому блоку установленные классы
    
    list_length - определяет количество элементов списка

Результат:

    <div class="widget-list __list1" id="widget-list1">
        <div class="widget-list__item widget-list__item1">
            1
        </div>
        <div class="widget-list__item widget-list__item2">
            2
        </div>
        <div class="widget-list__item widget-list__item3">
            3
        </div>
    </div>
 
По умолчанию элементы списка спозиционированы относительно друг друга внутри родительского блока, но их можно распределить по страничке с помощью css.



# test_custom_js_button

Виджет создает кнопку, которая вызывает функцию, прописанную в настройках (функцию можно задать в теле index.html). При создании шага эта кнопка помещается в блок button-block, внутри которого кнопки размещены как flex-элементы. 

    "test_custom_js_button": {
        "text": "Далее",
        "function": "step1_next_step"
    },

Возможные параметры:

    text - текст кнопки
    
    function - имя функции для исполнения
    
Результат:

    <div class="button" id="customButton">
        Далее
    </div>
    
      

# test_explain

Виджет создает скрытый блок с текстом/html и кнопку, которая показывает и скрывает его. Текст кнопки задается в параметрах (и должен быть задан обязательно). Этот виджет был сделан для того, чтобы показывать условия задания или какие либо комментарии.

     "test_explain": {
        "explain_message": "<img src='./img/explain_1.png' width='896' height='314'>",
        "button_text": "Вспомнить признаки делимости",
        "heading":"Признаки делимости"
    },
    
Параметры:

    explain_message - содержимое блока (текст/html),
    
    button_text - текст кнопки
    
    heading (не обязателен) - небольшой блок с заголовком расположенный справа над блоком сообщения

Результат:

    <div class="explain-heading hidden">
        Признаки делимости
    </div>
    
    <div class="explain-message hidden">
        <img src="./img/explain_1.png" width="896" height="314">
    </div>
    
    <div class="button" id="explainButton">
        Вспомнить признаки делимости
    </div>



# test_help

Виджет создает скрытый блок с текстом/html и кнопку, которая показывает и скрывает его. Текст кнопки стандартный ("Подсказка").

Этот вариант всплывающей подсказки появляется в интерфейсе только после первой неудачной проверки шага задания.

    "test_help": {
        "help_message": "<img src='./img/hint_1.png' width='346' height='250'>"
    },
    
Параметры:

    help_message - содержимое блока (текст/html),

Результат:

    <div class="help-message hidden">
        <img src="./img/hint_1.png" width="346" height="250">
    </div>
  
    <div class="button" id="helpButton">
        Подсказка
    </div>



# widget_button

Это один из вспомогательных виджетов, которые не вызываются из описания задачи напрямую. Он используется как конструктор кнопок для других виджетов. Виджет имеет набор параметров по умолчанию для создания кнопки проверки, которые применяются, если кнопка создается с параметром "type": "checkButton".

Этот виджет может быть использован для создания кнопок в пользовательских функциях.

Метод widget_button.create принимает в качестве аргумента объект со следующими параметрами:

    type (не обязателен) - используется для "предустановленных" настроек
        однако, единственное возможное значение - "checkButton"
    
    text (не обязателен) - текст кнопки, по умолчанию - "Нажать"
    
    id (не обязателен) - устанавливает атрибут id для блока кнопки
    classes (не обязателен) - добавляет установленные классы
    
    active (не обязателен) - активна ли кнопка изначально (по умолчанию - true)
    click - событие при нажатии
    
    successText - сохраняет в .data этот параметр, используется в логике checkButton
    
Пример результата:

    <div class="button" id="explainButton">
        Вспомнить признаки делимости
    </div>

Методы кнопки:

    widget_button.activate(button) - активирует указанную кнопку

    widget_button.deactivate(button) - делает кнопку не активной



# widget_overlay 

Это один из вспомогательных виджетов, которые не вызываются из описания задачи напрямую. Он используется как конструктор overlay'ев для других виджетов.

Этот виджет может быть использован для создания overlay'ев в пользовательских функциях.

Метод widget_overlay.create принимает в качестве аргумента объект со следующими параметрами:

    id (не обязателен) - устанавливает атрибут id для родительского блока
    classes (не обязателен) - добавляет установленные классы

    image - добавляет картинку (html) (обычно это inline svg)
    
    message - добавляет текст
    
    buttons - принимает массив с готовыми кнопками в качестве элементов, 
        чтобы поместить их в .overlay__buttons-block
 
Пример результата:

    <div class="overlay overlay_hidden" id="reload-dialog">
        <svg class="reloadDialog_image overlay__image" ... > ...</svg>
        <div class="overlay__message">
            Сбросить состояние текущего шага?
        </div>
        <div class="overlay__buttons-block">
            <div class="button button_reloadStep">Сбросить шаг</div>
        </div>
    </div>
    
Методы:

    widget_overlay.show(overlay) - анимация появления указанного overlay'а
    
    widget_overlay.hide(overlay) - анимация сокрытия overlay'а
    
    
    
# test_preloadimg

Этот виджет ничего не отображает, но служит для предварительной загрузки всех необходимых изображений, используемых в задании.

Необходимо разобраться, как он работает, исправить его, так как есть ощущение, что он не работает никак, и настроить затем для всех задач.
    


# test_textfields

Виджет textfields создает текстовые поля для ввода ответов. Правильные ответы указаны в настройках виджета. Виджет использует библиотеку jquery.caret.js

    "test_textfields": 
        [
            {
                "removeCharacters": ["(", ")", " "]
                "replaceCommas": true
                "checkAnyOrder": true
            },
            
            {
                "value": "1.5000", 
                "classes": "__textfield1"
            },
            {
                "value": "0.0858", 
                "classes": "__textfield2"
            }
        ]

Параметры виджета:

    removeCharacters - удаляет все символы, переданные в виде элементов массива
    
    replaceCommas - если true, то заменяет все запятые во введенном ответе на точки при проверке
    
    checkAnyOrder - настраивает проверку так, чтобы было не важно 
        в какие именно текстовые поля введен набор правильных ответов

Параметры элементов:

    value - в этом поле записывается правильный ответ
    
    classes - добавляет установленные классы
 
Результат:

    <div class="textfield __textfield1" id="textfield1" contenteditable="true"></div>
    
    <div class="textfield __textfield2" id="textfield2" contenteditable="true"></div>



# test_clickable

Виджет создает карточки (блок с text/html (например, изображениями) внутри), клик по которым выделяет их (то есть происходит выбор варианта ответа) или отменяет выделение.

Опция multiselect позволяет установить, можно ли выбрать только одну карточку одновременно (выбор предыдущей отменяется), или же может быть выбрано несколько.

В этом случае используется анимация для отображения такого результата проверки, когда нет неверно выбранных карточек, но выбраны не все верные ответы, и хотя бы одна из карточек не выбрана вообще. Это выглядит как подрагивание всех не выбранных карточек. Эта функция требует дополнительной работы по пониманию и объяснению алгоритма в комментариях и документации.

Опция autocheck определяет, проводится ли проверка автоматически при выборе карточки, или для этого требуется нажать на #checkButton.

Однажды проверенная как правильный ответ карточка деактивируется (то есть с нее уже нельзя снять выделение).

Описание:

    "test_clickable":
        [
            {
                "multiselect": true,
                "autocheck": false,
                "classes": "clickable_orange"
            },
            
            {
                "value": "Карточка 1",
                "right": false
            },
            {
                "value": "Карточка 2",
                "classes": "second-answer",
                "right": true
            }
        ]            

Параметры виджета:

    multiselect - включает возможность множественного выбора
    
    autocheck - включает проверку результата после каждого выбора (нажатия мышкой)
    
    classes - добавляет установленные классы 

Параметры элементов:

    value - текстовое или html содержание карточки
    
    classes - добавляет установленные классы     
    
    right - отмечает элемент как верный ответ
    
Результат:

    <div class="clickable multiselect clickable_orange" id="clickable1">
        <div class="inner-element">
            Карточка 1
        </div>
    </div>        
    
    <div class="clickable multiselect clickable_orange second-answer" id="clickable2">
        <div class="inner-element">
            Карточка 2
        </div>
    </div>



# test_multiclickable

Этот виджет предполагает использование одного изображения, на котором размечены отдельные области для нажатия.

На данный момент он нигде не используется и является legacy-функционалом. Необходимо разобраться как он работает и довести до пригодного уровня, или же исключить его из актуальной версии фреймворка.



# test_sortable

Виджет предполагает сортировку нескольких блоков в правильном порядке (путем перетаскивания). Он реализован на базе соответствующего функционала jQuery UI. Изначально блоки распределены в случайном (но не правильном) порядке.

Виджет создает абсолютно спозиционированный блок, внутри которого находятся элементы для сортировки.

Могут быть созданы несколько таких независимых блоков, но, пока что, проверяется правильность всех сразу.

Правильным ответом считается тот порядок элементов, в котором они заданы в описании виджета:

    "test_sortable":
        [
            {
                "axis": "x",
                
                "items":
                    [
                        {

                        },
                        {
                            "value": "Первый по порядку элемент",
                        },
                        {
                            "value": "Второй элемент",
                        },
                        {
                            "value": "Третий элемент",
                        }
                    ]
            },      
            {
                "items":
                    [
                        {

                        },
                        {
                            "value": "Первый по порядку элемент",
                        },
                        {
                            "value": "Второй элемент",
                        },
                        {
                            "value": "Третий элемент",
                        }
                    ]
            }
        ]
                    
Параметры виджета:

    axis - задает ось перемещения сортируемых элементов 
    
    // передает свое значение в параметр axis настроек jQuery UI Sortable, а также
    // добавляет класс sortableblock_axis_x блоку сортируемых элементов
    
    // возможные значения - x или y (по умолчанию - y)
    
Параметры элементов: 
    
    value - внутреннее содержание элемента сортировки (text/html) - не обязателен

Результат:

    <div class="sortableblock sortableblock_axis_x ui-sortable" id="sortableblock0">
        <div class="sortable sortable1 ui-sortable-handle">
            Первый по порядку элемент
        </div>
        <div class="sortable sortable3 ui-sortable-handle">
            Третий элемент
        </div>
        <div class="sortable sortable2 ui-sortable-handle">
            Второй элемент
        </div>
    </div>
    
    <div class="sortableblock ui-sortable" id="sortableblock1">
        <div class="sortable sortable3 ui-sortable-handle">
            Третий элемент</div>
        <div class="sortable sortable2 ui-sortable-handle">
            Второй элемент
        </div>
        <div class="sortable sortable1 ui-sortable-handle">
            Первый по порядку элемент
        </div>
    </div>

Виджет позволяет создать несколько блоков для сортировки, однако, проверка в этом случае пока не работает.



# test_drag_n_drop

Этот наиболее сложный и чаще всего используемый виджет. Он предполагает распределение карточек по соответствующим им "ловушкам" посредством перетаскивания. Он реализован на базе соответствующего функционала jQuery UI.

Виджет создает указанное в настройках количество блоков-карточек (draggable) и блоков-ловушек (droppable). Правильные ответы описаны в свойствах ловушек (их может быть несколько вариантов для каждой ловушки).

Правильность ответа проверяется по соответствию содержания блока (value) любому из значений, прописанных для ловушки (values). Причем этим значением может быть как текст, так и html! Пустые (без карточки внутри) ловушки с пустой строкой в свойстве values проверяются как правильные ответы.

С помощью свойства content можно задать отдельно содержимое для краточки. Если параметр content задан, то проверка осуществляется по значению value, но это значение не включается в html.

Если не указаны дополнительные опции, то для активации кнопки проверки все ловушки должны быть заполнены. Но если опция включена emptyCheck, то для активации кнопки проверки достаточно перетащить любую карточку в любую ловушку.

Карточки и ловушки могут быть разбиты на группы элементов, которые могут взаимодействовать между собой (игонрируют элементы не своей группы). Для обозначения группы элементам draggable и droppable нужно указать одинаковое значение свойства scope. 

Если для карточек задано свойство returnable, то при отпускании карточки в любом месте вне ловушки она возвращается на изначальное место.

Однажды проверенная как правильный ответ карточка и соответствующая (занятая ей) ловушка деактивируются (то есть ее/в нее больше нельзя перетаскивать).

Существует анимация вибрации для неиспользованных карточек при клике на пустую ловушку.

Stack mode:

Если свойство stackMode указано как true, то вместо карточек создаются "стопки" с бесконечным количеством карточек в них. В этом случае отпускаемые где либо кроме ловушки карточки просто исчезают. Карточки, которые были вытеснены из ловушки другой перетащенной туда карточкой, также исчезают.

Свойство stackMode может быть указано в настройках виджета, общих настройках draggable или индивидуально для любого draggable (данная функциональность находится в стадии бета-версии).

Возможность задать stackMode индивидуально предполагает использование вместе с группировкой по scope. Использоване без группировки находится в стадии бета-версии.

Для визуального оформления stackMode создаются элементы .draggables-stack, для которых следует указывать такое же позиционирование и размер, как для элементов draggable. 

Элементы stack имеют id вида #draggable1-stack, номер в котором соотетствует своему draggable (то есть номера могут идти не подряд)

Описание:

    "test_drag_n_drop": {
        "emptyCheck": false,
        "deactivateCheckButton": false,
        "stackMode": false,

        "draggables":
            [
                {
                    "returnable": true
                },

                {
                    "value": "<i>1</i>",
                    "content": "Some content",
                    "scope": "scope1"
                },
                {
                    "value": "<b>2</b>",
                    "scope": "scope1",
                    "stackMode": true,
                },
                {
                    "value": "3",
                    "returnable": false,
                    "scope": "scope2",
                    "classes": "second-scope"
                }
            ],

        "droppables":
            [
                {
                    "classes": "droppable_special"
                },

                {
                    "values":
                        [
                            "<i>1</i>",
                            "<b>2</b>"
                        ],
                    "scope": "scope1"
                },
                {
                    "values":
                        [
                            "<i>1</i>",
                            "<b>2</b>"
                        ],
                    "scope": "scope1"
                },
                {
                    "values": "3",
                    "scope": "scope2",
                    "classes": "second-scope"
                },
            ]
    }

Свойства виджета:

    stackMode - включает режим с бесконечными карточками (по умолчанию false)
    emptyCheck - меняет режим активации кнопки проверки (по умолчанию false)
    deactivateCheckButton - делает неактиной #checkButton при каждой неуспешной проверке (по умолчанию true)

Свойства draggable общие:
    
    stackMode - включает режим с бесконечными карточками (по умолчанию false)
    returnable - включает/выключает возвращение карточек на место 
    scope - задает группы для элементов виджета
    classes - добавляет установленные классы   
    stackClasses - добавляет классы для stack-элемента   

    // далее - параметры, переопределяющие значения для jQuery UI
    axis
    containment
    cursorAt
    
Свойства draggable элемента:

    value - значение для проверки/содержимое краточки
    content - содержимое карточки (если задан этот параметр, то value не отображается)
    
    stackMode - включает режим с бесконечными карточками (по умолчанию false)
    returnable - включает/выключает возвращение карточек на место 
    scope - задает группы для элементов виджета
    classes - добавляет установленные классы
    stackClasses - добавляет классы для stack-элемента
    
    // далее - параметры, переопределяющие значения для jQuery UI
    axis
    containment
    cursorAt

Свойства droppable общие:

    alwaysShowRW - (?) отображение результата проверки для ловушек
        (для данной опции отсутствует преднастроенный css)
    
    scope - задает группы для элементов виджета
    classes - добавляет установленные классы

Свойства droppable элемента:

    values - значения содержимого карточки, которые считаются 
        правильным ответом для этой ловушки
        (строка либо массив строк)
    
    alwaysShowRW - (?) отображение результата проверки для ловушек
        (для данной опции отсутствует преднастроенный css)
    
    scope - задает группы для элементов виджета
    classes - добавляет установленные классы
    
Результат:

    <div id="dragNDropContainer">
        <div class="droppable droppable_special ui-droppable" id="droppable1"></div>
        <div class="droppable droppable_special ui-droppable" id="droppable2"></div>
        <div class="droppable droppable_special second-scope ui-droppable" id="droppable3"></div>
        
        <div class="draggable ui-draggable ui-draggable-handle" id="draggable1" 
        style="position: relative;">
            <div class="inner-element">
                Some content
            </div>
        </div>
        
        <div class="draggables-stack" id="draggable2-stack"></div>
        <div class="draggable ui-draggable ui-draggable-handle" id="draggable2" 
        style="position: relative;">
            <div class="inner-element">
                <b>2</b>
            </div>
        </div>
        
        <div class="draggable second-scope ui-draggable ui-draggable-handle" id="draggable3" 
        style="position: relative;">
            <div class="inner-element">
                3
            </div>
        </div>
    </div>



# test_checkbox

Этот виджет работает по аналогии с test_radiobutton, однако, требует доработки функционала и полной переработки css. 



# test_radiobutton

Виджет предполагает выбор одного из нескольких вариантов ответа при помощи элемента radio button. 

Возможно создание нескольких групп вопросов (на каждый из которых можно выбрать один ответ). Для этого используется свойство group. 

Виджет создает блоки, содержащие в себе элемент-иконку и элемент-подпись.

Существует преднастроенный класс (.radio-label_frame) для графического оформления блока ответа как поля с фоном. 

Описание:

    "test_radiobutton":
        [
            {
                "classes": "radio-label_frame"
            },
        
            {
                "value": "25x − 17y = 0",
                "right": true,
                "group": "group1",
                "classes": "radio-label_right"
            },
            {
                "value": "25x + 17y = 0",
                "group": "group1"
            },
    
            {
                "value": "x= 17t, y = −25t",
                "right": true,
                "group": "group2"
            },
            {
                "value": "x = 25t, y = −17t",
                "group": "group2"
            }
        ]


Свойства виджета:

    classes - добавляет установленные классы

Свойства элемента:

    value - содержание подписи виджета 
    group - группа ответов
    
    right - объявляет правильный ответ
        (может быть задан только один правильный ответ)
    
    classes - добавляет установленные классы  

Результат (элемент input скрыт):

    <input class="radio-input" type="radio" id="radio-input1" name="group1">
    <label class="radio-label radio-label1 radio-label_frame radio-label_right" 
    for="radio-input1">
        <div class="radio-icon"></div>
        <div class="radio-caption">
            25x − 17y = 0
        </div>
    </label>
    
    <input class="radio-input" type="radio" id="radio-input2" name="group1">
    <label class="radio-label radio-label2 radio-label_frame" for="radio-input2">
        <div class="radio-icon"></div>
        <div class="radio-caption">
            25x + 17y = 0
        </div>
    </label>
    
    <input class="radio-input" type="radio" id="radio-input3" name="group2">
    <label class="radio-label radio-label3 radio-label_frame" for="radio-input3">
        <div class="radio-icon"></div>
        <div class="radio-caption">
            x= 17t, y = −25t
        </div>
    </label>
    
    <input class="radio-input" type="radio" id="radio-input4" name="group2">
    <label class="radio-label radio-label4 radio-label_frame" for="radio-input4">
        <div class="radio-icon"></div>
        <div class="radio-caption">
            x = 25t, y = −17t
        </div>
    </label>



# Дополнительное описание для разработчиков

 ...

















































